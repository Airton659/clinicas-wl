// lib/api/api_service.dart

import 'dart:convert';
import 'dart:typed_data';
import 'package:analicegrubert/models/anamnese.dart';
import 'package:analicegrubert/models/consulta.dart';
import 'package:analicegrubert/models/diario.dart';
import 'package:analicegrubert/models/exame.dart';
import 'package:analicegrubert/models/ficha_completa.dart';
import 'package:analicegrubert/models/orientacao.dart';
import 'package:analicegrubert/models/checklist_item.dart';
import 'package:analicegrubert/models/paciente.dart';
import 'package:analicegrubert/models/usuario.dart';
import 'package:analicegrubert/models/suporte_psicologico.dart';
import 'package:analicegrubert/models/relatorio_medico.dart';
import 'package:analicegrubert/models/relatorio_detalhado.dart';
import 'package:analicegrubert/models/notificacao.dart';
import 'package:analicegrubert/services/auth_service.dart';
import 'package:analicegrubert/models/tarefa_agendada.dart';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:http_parser/http_parser.dart';
import 'package:analicegrubert/models/registro_diario.dart';
import 'package:analicegrubert/utils/error_handler.dart';
import 'package:analicegrubert/services/cache_manager.dart';
import 'package:intl/intl.dart';

// Estrutura de cache com TTL
class CacheEntry<T> {
  final T data;
  final DateTime timestamp;
  final Duration ttl;
  
  CacheEntry(this.data, this.ttl) : timestamp = DateTime.now();
  
  bool get isExpired => DateTime.now().difference(timestamp) > ttl;
}

class ApiService {
  final String _baseUrl =
      'https://barbearia-backend-service-862082955632.southamerica-east1.run.app';
  final AuthService _authService;

  // Função estática para construir URLs de imagem
  static String buildImageUrl(String? imagePath) {
    if (imagePath == null || imagePath.isEmpty) return '';
    
    // Se já é uma URL completa, retorna como está
    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
      return imagePath;
    }
    
    // Se é um caminho relativo, adiciona a URL base
    if (imagePath.startsWith('/')) {
      return 'https://barbearia-backend-service-862082955632.southamerica-east1.run.app$imagePath';
    }
    
    // Se não tem '/' no início, adiciona
    return 'https://barbearia-backend-service-862082955632.southamerica-east1.run.app/$imagePath';
  }
  
  // Cache interno com TTL de 5 minutos por padrão
  final Map<String, CacheEntry> _cache = {};
  final Duration _defaultTtl = const Duration(minutes: 5);
  final CacheManager _cacheManager = CacheManager.instance;
  
  // Controle de cache por usuário
  DateTime? _lastUserLogin;

  ApiService({required AuthService authService}) : _authService = authService;

  // Métodos de cache
  String _getCacheKey(String endpoint, [Map<String, dynamic>? params]) {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final negocioId = _authService.getNegocioId() ?? 'default';
    final paramString = params?.entries.map((e) => '${e.key}=${e.value}').join('&') ?? '';
    return '${userId}_${negocioId}_${endpoint}_$paramString';
  }
  
  T? _getFromCache<T>(String cacheKey) {
    final entry = _cache[cacheKey] as CacheEntry<T>?;
    if (entry != null && !entry.isExpired) {
      debugPrint('[Cache HIT] $cacheKey');
      return entry.data;
    }
    if (entry != null && entry.isExpired) {
      _cache.remove(cacheKey);
      debugPrint('[Cache EXPIRED] $cacheKey');
    }
    return null;
  }
  
  void _setCache<T>(String cacheKey, T data, {Duration? ttl}) {
    _cache[cacheKey] = CacheEntry<T>(data, ttl ?? _defaultTtl);
    debugPrint('[Cache SET] $cacheKey (TTL: ${ttl ?? _defaultTtl})');
  }
  
  void clearCache([String? pattern]) async {
    final userId = _authService.currentUser?.id;
    final negocioId = await _authService.getNegocioId();
    
    debugPrint('[CACHE AGGRESSIVE CLEAR] Limpando cache - Pattern: $pattern, UserId: $userId, NegocioId: $negocioId');
    
    // Limpa cache em memória (legacy) - MAIS AGRESSIVO
    if (pattern != null) {
      final keysToRemove = _cache.keys.where((key) => key.contains(pattern)).toList();
      for (final key in keysToRemove) {
        _cache.remove(key);
        debugPrint('[CACHE MEMORY CLEAR] Removida key: $key');
      }
    } else {
      _cache.clear();
      debugPrint('[CACHE MEMORY CLEAR] Cache em memória completamente limpo');
    }
    
    // Limpa cache persistente - FORÇADO
    try {
      if (userId != null && negocioId != null) {
        await _cacheManager.clear(
          pattern: pattern,
          userId: userId,
          negocioId: negocioId,
        );
        debugPrint('[CACHE DISK CLEAR] Cache persistente limpo para usuário específico');
      } else {
        await _cacheManager.clear(pattern: pattern);
        debugPrint('[CACHE DISK CLEAR] Cache persistente limpo globalmente');
      }
    } catch (e) {
      debugPrint('[CACHE CLEAR ERROR] Erro ao limpar cache persistente: $e');
    }
    
    // FORÇA limpeza adicional para padrões específicos problemáticos
    if (pattern == 'getPacientes') {
      try {
        await _cacheManager.clear(); // Limpa TUDO relacionado a pacientes
        debugPrint('[CACHE NUCLEAR] Limpeza nuclear do cache de pacientes');
      } catch (e) {
        debugPrint('[CACHE NUCLEAR ERROR] $e');
      }
    }
  }

  Future<Map<String, String>> _getHeaders() async {
    final token = await _authService.getIdToken();
    final negocioId = await _authService.getNegocioId();

    debugPrint('========== _getHeaders DEBUG ==========');
    debugPrint('Token is null: ${token == null}');
    debugPrint('NegocioId is null: ${negocioId == null}');
    debugPrint('NegocioId value: $negocioId');
    if (token != null) {
      debugPrint('Token length: ${token.length} characters');
    }

    if (token == null || negocioId == null) {
      debugPrint('ERRO: Token ou negocioId é null!');
      throw Exception('User not authenticated or negocioId not found.');
    }

    final headers = {
      'Content-Type': 'application/json; charset=UTF-8',
      'Authorization': 'Bearer $token',
      'negocio-id': negocioId,
    };

    debugPrint('Headers finais: ${headers.keys.toList()}');
    debugPrint('negocio-id no header: ${headers['negocio-id']}');
    debugPrint('=====================================');

    return headers;
  }

  // --- ANAMNESE ---

  Future<Anamnese> createAnamnese(String pacienteId, Map<String, dynamic> data) async {
    final negocioId = await _authService.getNegocioId();
    final url = '$_baseUrl/pacientes/$pacienteId/anamnese?negocio_id=$negocioId';
    final uri = Uri.parse(url);
    
    debugPrint('--- [DEBUG] CRIANDO ANAMNESE ---');
    debugPrint('URL: $uri');
    debugPrint('BODY: ${json.encode(data)}');

    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );
    if (response.statusCode == 201) {
      return Anamnese.fromJson(json.decode(response.body));
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<List<Anamnese>> getAnamneseHistory(String pacienteId) async {
    final negocioId = await _authService.getNegocioId();
    final url = '$_baseUrl/pacientes/$pacienteId/anamnese?negocio_id=$negocioId';
    final uri = Uri.parse(url);
    final response = await http.get(uri, headers: await _getHeaders());
    if (response.statusCode == 200) {
      final List<dynamic> jsonData = json.decode(response.body);
      return jsonData.map((json) => Anamnese.fromJson(json)).toList();
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<Anamnese> updateAnamnese(String anamneseId, Map<String, dynamic> data) async {
    final url = '$_baseUrl/anamnese/$anamneseId';
    final uri = Uri.parse(url);

    debugPrint('--- [DEBUG] ATUALIZANDO ANAMNESE ---');
    debugPrint('URL: $uri');
    debugPrint('BODY: ${json.encode(data)}');

    final response = await http.put(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );
    if (response.statusCode == 200) {
      return Anamnese.fromJson(json.decode(response.body));
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  // --- TESTE DE PROFILE ---

  Future<void> testProfileEndpoint() async {
    debugPrint('========== TESTE /me/profile ==========');
    try {
      final uri = Uri.parse('$_baseUrl/me/profile');
      final headers = await _getHeaders();
      
      debugPrint('URL: $uri');
      debugPrint('Headers enviados:');
      headers.forEach((key, value) {
        debugPrint('  $key: ${key == 'Authorization' ? '${value.substring(0, 20)}...' : value}');
      });
      
      final response = await http.get(uri, headers: headers);
      
      debugPrint('Status: ${response.statusCode}');
      debugPrint('Body: ${response.body}');
      debugPrint('=====================================');
    } catch (e) {
      debugPrint('ERRO no teste de profile: $e');
    }
  }

  // Método para obter dados atualizados do perfil do usuário
  Future<Usuario?> getCurrentUserProfile() async {
    try {
      final uri = Uri.parse('$_baseUrl/me/profile');
      final headers = await _getHeaders();
      
      final response = await http.get(uri, headers: headers);
      
      if (response.statusCode == 200) {
        final responseBody = json.decode(response.body);
        return Usuario.fromJson(responseBody);
      } else {
        debugPrint('[ApiService] Erro ao buscar perfil: ${response.statusCode}');
        return null;
      }
    } catch (e) {
      debugPrint('[ApiService] Erro ao buscar perfil: $e');
      return null;
    }
  }

  // --- FCM TOKEN (NOTIFICAÇÕES) ---

  Future<void> registerFcmToken(String token) async {
    final uri = Uri.parse('$_baseUrl/me/register-fcm-token');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode({'token': token}),
    );
    if (response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }


  // --- UPLOAD DE ARQUIVOS ---

  Future<Map<String, dynamic>> uploadFoto(String filePath) async {
    final uri = Uri.parse('$_baseUrl/upload-foto');
    final request = http.MultipartRequest('POST', uri);
    
    final headers = await _getHeaders();
    request.headers.addAll(headers);
    
    request.files.add(await http.MultipartFile.fromPath('file', filePath));
    
    final streamedResponse = await request.send();
    final response = await http.Response.fromStream(streamedResponse);
    
    if (response.statusCode == 200) {
      return json.decode(response.body);
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<Map<String, dynamic>> uploadFile(String filePath) async {
    final uri = Uri.parse('$_baseUrl/upload-file');
    final request = http.MultipartRequest('POST', uri);
    
    final headers = await _getHeaders();
    request.headers.addAll(headers);
    
    request.files.add(await http.MultipartFile.fromPath('file', filePath));
    
    final streamedResponse = await request.send();
    final response = await http.Response.fromStream(streamedResponse);
    
    if (response.statusCode == 200) {
      return json.decode(response.body);
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  // --- MÉTODOS DE CRIAÇÃO DO PLANO DE CUIDADO ---

  // *** MÉTODO CORRIGIDO ***
  Future<Orientacao> createOrientacao(
    String pacienteId,
    String consultaId, // Recebe o ID da consulta separado
    Map<String, dynamic> data,
  ) async {
    // Adiciona o consulta_id como query parameter na URL
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/orientacoes?consulta_id=$consultaId');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data), // O body não contém mais o consulta_id
    );

    if (response.statusCode == 201) {
      final orientacao = Orientacao.fromJson(json.decode(response.body));
      await invalidateRelatedCache('patient_updated', pacienteId: pacienteId);
      return orientacao;
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  // *** MÉTODO CORRIGIDO ***
  Future<ChecklistItem> createChecklistItem(
    String pacienteId,
    String consultaId, // Recebe o ID da consulta separado
    Map<String, dynamic> data,
  ) async {
    // Adiciona o consulta_id como query parameter na URL
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/checklist-itens?consulta_id=$consultaId');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data), // O body não contém mais o consulta_id
    );

    if (response.statusCode == 201) {
      return ChecklistItem.fromJson(json.decode(response.body));
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  // *** MÉTODO CORRIGIDO ***
  Future<void> createMedicacao(
    String pacienteId,
    String consultaId, // Recebe o ID da consulta separado
    Map<String, dynamic> data,
  ) async {
    // Adiciona o consulta_id como query parameter na URL
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/medicacoes?consulta_id=$consultaId');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data), // O body não contém mais o consulta_id
    );

    if (response.statusCode != 201) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> createExame(String pacienteId, Map<String, dynamic> data) async {
    final negocioId = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/exames?negocio_id=$negocioId');
    
    final bodyData = Map<String, dynamic>.from(data);
    debugPrint('--- [DEBUG] CRIANDO EXAME ---');
    debugPrint('URL: $uri');
    debugPrint('BODY: ${json.encode(bodyData)}');
    debugPrint('------------------------------------');
    
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(bodyData),
    );
    
    debugPrint('Status: ${response.statusCode}');
    debugPrint('Response: ${response.body}');
    debugPrint('------------------------------------');

    if (response.statusCode != 201) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<List<Exame>> getExames(String pacienteId, {bool forceRefresh = false}) async {
    final cacheKey = _getCacheKey('getExames', {'pacienteId': pacienteId});
    
    if (!forceRefresh) {
      final cached = _getFromCache<List<Exame>>(cacheKey);
      if (cached != null) return cached;
    }
    
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/exames');
    
    try {
      final response = await http.get(
        uri,
        headers: await _getHeaders(),
      );

      debugPrint('--- RESPOSTA DO SERVIDOR (getExames) ---');
      debugPrint('URL: $uri');
      debugPrint('Status Code: ${response.statusCode}');
      debugPrint('Body: ${response.body}');
      debugPrint('----------------------------------------');

      if (response.statusCode == 200) {
        final List<dynamic> jsonList = json.decode(response.body);
        final List<Exame> exames = jsonList
            .map((json) => Exame.fromJson(json as Map<String, dynamic>))
            .toList();
        
        _setCache(cacheKey, exames, ttl: const Duration(minutes: 5));
        return exames;
      } else if (response.statusCode == 404) {
        _setCache(cacheKey, <Exame>[], ttl: const Duration(minutes: 5));
        return <Exame>[];
      } else {
        throw Exception(ErrorHandler.getApiErrorMessage(response));
      }
    } catch (e) {
      debugPrint('Erro em getExames: $e');
      throw Exception('Falha ao carregar exames. Verifique sua conexão ou tente novamente mais tarde.');
    }
  }

  Future<void> updateExame(String pacienteId, String exameId, Map<String, dynamic> data) async {
    final negocioId = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/exames/$exameId?negocio_id=$negocioId');
    
    final bodyData = Map<String, dynamic>.from(data);
    
    debugPrint('--- [DEBUG] ATUALIZANDO EXAME ---');
    debugPrint('URL: $uri');
    debugPrint('ExameId: $exameId');
    debugPrint('PacienteId: $pacienteId');
    debugPrint('BODY: ${json.encode(bodyData)}');
    debugPrint('------------------------------------');
    
    final response = await http.put(
      uri,
      headers: await _getHeaders(),
      body: json.encode(bodyData),
    );
    
    debugPrint('Status: ${response.statusCode}');
    debugPrint('Response: ${response.body}');
    debugPrint('------------------------------------');

    if (response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
    
    final cacheKey = _getCacheKey('getExames', {'pacienteId': pacienteId});
    _cache.remove(cacheKey);
  }

  Future<void> deleteExame(String pacienteId, String exameId) async {
    final negocioId = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/exames/$exameId?negocio_id=$negocioId');
    
    debugPrint('--- [DEBUG] DELETANDO EXAME ---');
    debugPrint('URL: $uri');
    debugPrint('ExameId: $exameId');
    debugPrint('PacienteId: $pacienteId');
    debugPrint('------------------------------------');
    
    final response = await http.delete(
      uri,
      headers: await _getHeaders(),
    );
    
    debugPrint('Status: ${response.statusCode}');
    debugPrint('Response: ${response.body}');
    debugPrint('------------------------------------');

    if (response.statusCode != 200 && response.statusCode != 204) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
    
    final cacheKey = _getCacheKey('getExames', {'pacienteId': pacienteId});
    _cache.remove(cacheKey);
  }

  // CAMPO PRONTUÁRIO COMENTADO A PEDIDO DO CLIENTE (manter para possível reativação futura)
  /*
  Future<void> createProntuario(String pacienteId, Map<String, dynamic> data) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/prontuarios');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );

    if (response.statusCode != 201) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }
  */

  // --- FICHA COMPLETA ---
  
  Future<FichaCompleta> getFichaCompleta(
    String pacienteId, {
    String? consultaId,
    bool forceRefresh = false,
  }) async {
    final cacheKey = _getCacheKey('getFichaCompleta', {
      'pacienteId': pacienteId,
      'consultaId': consultaId ?? 'null',
    });
    
    if (!forceRefresh) {
      final cached = _getFromCache<FichaCompleta>(cacheKey);
      if (cached != null) return cached;
    }
    
    String url = '$_baseUrl/pacientes/$pacienteId/ficha-completa';

    if (consultaId != null && consultaId.isNotEmpty) {
      url += '?consulta_id=$consultaId';
    } else {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      url += '?t=$timestamp';
    }

    final uri = Uri.parse(url);

    try {
      final response = await http.get(
        uri,
        headers: await _getHeaders()
      ).timeout(const Duration(seconds: 30));

      debugPrint('--- RESPOSTA DO SERVIDOR (getFichaCompleta) ---');
      debugPrint('URL: $url');
      debugPrint('Status Code: ${response.statusCode}');
      debugPrint('Body: ${response.body}');
      debugPrint('------------------------------------------------');

      if (response.statusCode == 200) {
        final dynamic jsonData = json.decode(response.body);
        final fichaCompleta = FichaCompleta.fromJson(jsonData);
        
        _setCache(cacheKey, fichaCompleta, ttl: const Duration(minutes: 3));
        return fichaCompleta;
      } else {
        throw Exception(ErrorHandler.getApiErrorMessage(response));
      }
    } catch (e) {
      debugPrint('Erro em getFichaCompleta: $e');
      throw Exception('Falha ao carregar os dados do paciente. Verifique sua conexão ou tente novamente mais tarde.');
    }
  }

  // --- PACIENTES ---

  Future<void> updatePatientPersonalData(String pacienteId, Map<String, dynamic> data) async {
    try {
      final userId = _authService.currentUser?.id;
      final negocioId = await _authService.getNegocioId();
      final token = await _authService.getIdToken();

      if (userId == null || negocioId == null || token == null) {
        throw Exception('Usuário não autenticado ou dados de negócio indisponíveis');
      }

      final url = '$_baseUrl/pacientes/$pacienteId/dados-pessoais?negocio_id=$negocioId';
      
      final headers = <String, String>{
        'Content-Type': 'application/json; charset=UTF-8',
        'Authorization': 'Bearer $token',
      };

      final response = await http.put(
        Uri.parse(url),
        headers: headers,
        body: jsonEncode(data),
      ).timeout(const Duration(seconds: 30));

      if (response.statusCode == 200) {
        _invalidatePatientCache(userId, negocioId);
      } else {
        final errorData = jsonDecode(response.body);
        throw Exception(errorData['detail'] ?? 'Erro ao atualizar dados pessoais');
      }
    } catch (e) {
      debugPrint('[ApiService] Erro ao atualizar dados pessoais: $e');
      rethrow;
    }
  }

  void _invalidatePatientCache(String userId, String negocioId) {
    final keys = _cache.keys.where((key) => key.contains('getPacientes')).toList();
    for (final key in keys) {
      _cache.remove(key);
    }
    
    debugPrint('[ApiService] Cache de pacientes invalidado');
  }
  
  Future<List<Paciente>> getPacientes({bool forceRefresh = false}) async {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final userRole = _authService.currentUser?.roles?[await _authService.getNegocioId() ?? 'default'] ?? 'unknown';
    final negocioId = await _authService.getNegocioId() ?? 'default';
    
    debugPrint('[ApiService] ========== GETPACIENTES DEBUG ==========');
    debugPrint('[ApiService] User Role: $userRole');
    debugPrint('[ApiService] User ID: $userId');
    
    final currentTime = DateTime.now();
    if (_lastUserLogin == null || currentTime.difference(_lastUserLogin!) > const Duration(minutes: 2)) {
      _lastUserLogin = currentTime;
      forceRefresh = true;
      debugPrint('[CACHE BYPASS] Forçando refresh - primeira chamada após login');
    }
    
    if (!forceRefresh) {
      final cached = await _cacheManager.get<List<dynamic>>(
        'getPacientes',
        userId,
        negocioId,
      );
      if (cached != null) {
        debugPrint('[CACHE HIT] Usando cache de pacientes');
        final pacientes = cached.map((json) => Paciente.fromJson(json)).toList();
        
        _preloadPatientDetails(pacientes.take(3).toList());
        
        return pacientes;
      }
    }
    
    final uri = Uri.parse('$_baseUrl/me/pacientes');
    debugPrint('========== getPacientes REQUEST DEBUG ==========');
    debugPrint('[ApiService] URL completa: $uri');
    
    try {
      final headers = await _getHeaders();
      debugPrint('[ApiService] TODOS os headers que serão enviados:');
      headers.forEach((key, value) {
        debugPrint('  $key: ${key == 'Authorization' ? '${value.substring(0, 20)}...' : value}');
      });
      
      final response = await http.get(uri, headers: headers);
      
      debugPrint('[ApiService] Status da resposta: ${response.statusCode}');
      debugPrint('[ApiService] Body da resposta: ${response.body}');
      debugPrint('============================================');
      if (response.statusCode == 200) {
        debugPrint('[ApiService] SUCESSO (200) ao buscar pacientes.');
        final List<dynamic> jsonData = json.decode(response.body);
        
        debugPrint('[ApiService] ========== DEBUG PACIENTES ==========');
        for (int i = 0; i < jsonData.length && i < 3; i++) {
          final patientData = jsonData[i];
          debugPrint('[ApiService] Paciente $i: nome="${patientData['nome']}", email="${patientData['email']}"');
        }
        debugPrint('[ApiService] ==========================================');
        
        final pacientes = jsonData.map((json) => Paciente.fromJson(json)).toList();
        
        await _cacheManager.set(
          'getPacientes',
          jsonData,
          userId,
          negocioId,
          ttl: const Duration(minutes: 5),
        );
        
        _preloadPatientDetails(pacientes.take(3).toList());
        
        return pacientes;
      } else {
        debugPrint(
          '[ApiService] ERRO ao buscar pacientes. Status: ${response.statusCode}, Corpo: ${response.body}',
        );
        throw Exception(
          'Failed to load patients. Status code: ${response.statusCode}',
        );
      }
    } catch (e) {
      debugPrint('[ApiService] EXCEÇÃO na chamada de getPacientes: $e');
      
      final cached = await _cacheManager.get<List<dynamic>>(
        'getPacientes',
        userId,
        negocioId,
      );
      if (cached != null) {
        debugPrint('[ApiService] Usando cache como fallback');
        final pacientes = cached.map((json) => Paciente.fromJson(json)).toList();
        
        _preloadPatientDetails(pacientes.take(3).toList());
        
        return pacientes;
      }
      
      rethrow;
    }
  }

  // --- CONSULTAS ---
  
  Future<Consulta> createConsulta(
    String pacienteId,
    Map<String, dynamic> data,
  ) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/consultas');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );

    if (response.statusCode == 201) {
      return Consulta.fromJson(json.decode(response.body));
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  // --- DIÁRIO SIMPLES (MANTIDO PARA COMPATIBILIDADE) ---
  
  Future<List<Diario>> getDiario(String pacienteId) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/diario');
    final response = await http.get(uri, headers: await _getHeaders());

    if (response.statusCode == 200) {
      final List<dynamic> jsonData = json.decode(response.body);
      return jsonData.map((json) => Diario.fromJson(json)).toList();
    } else {
      throw Exception(
        'Failed to load diario. Status code: ${response.statusCode}',
      );
    }
  }

  Future<Diario> createDiario(
    String pacienteId,
    Map<String, dynamic> data,
  ) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/diario');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );

    if (response.statusCode == 201) {
      return Diario.fromJson(json.decode(response.body));
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<Diario> updateDiario(
    String diarioId,
    Map<String, dynamic> data,
  ) async {
    final uri = Uri.parse('$_baseUrl/diario/$diarioId');
    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );

    if (response.statusCode == 200) {
      return Diario.fromJson(json.decode(response.body));
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> deleteDiario(String diarioId) async {
    final uri = Uri.parse('$_baseUrl/diario/$diarioId');
    final response = await http.delete(uri, headers: await _getHeaders());

    if (response.statusCode != 204) {
      throw Exception(
        'Failed to delete diario entry. Status code: ${response.statusCode}',
      );
    }
  }

  // --- USUÁRIOS E PATIENTS ---
  
  Future<Usuario> createPatient(Map<String, dynamic> data) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) {
      throw Exception('Negocio ID não encontrado.');
    }

    final uri = Uri.parse('$_baseUrl/negocios/$negocioId/pacientes');
    debugPrint('[ApiService] CHAMANDO POST: $uri');

    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );

    if (response.statusCode == 200 || response.statusCode == 201) {
      debugPrint('[ApiService] SUCESSO ao criar paciente.');
      debugPrint('[ApiService] sync-profile response: ' + response.body.toString());
      
      clearCache('getAllUsersInBusiness');
      clearCache('getAllPatients');
      debugPrint('[ApiService] Cache limpo após criar paciente.');
      
      return Usuario.fromJson(json.decode(response.body));
    } else {
      debugPrint(
        '[ApiService] ERRO ao criar paciente. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao criar paciente.');
    }
  }

  Future<void> updatePatientAddress(String patientId, Map<String, dynamic> addressData) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) {
      throw Exception("Negocio ID não encontrado para adicionar à URL.");
    }
    
    final url = '$_baseUrl/pacientes/$patientId/endereco?negocio_id=$negocioId';
    final uri = Uri.parse(url);
    
    debugPrint('--- [DEBUG] ATUALIZANDO ENDEREÇO ---');
    debugPrint('URL: $uri');
    debugPrint('BODY: ${json.encode(addressData)}');
    debugPrint('------------------------------------');

    final response = await http.put(
      uri,
      headers: await _getHeaders(),
      body: json.encode(addressData),
    );

    if (response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
    
    // Invalidar cache após atualização bem-sucedida
    await invalidateRelatedCache('patient_updated', pacienteId: patientId);
  }

  Future<Usuario> syncProfile(Map<String, dynamic> data) async {
    final uri = Uri.parse('$_baseUrl/users/sync-profile');
    
    final headers = await _getHeaders();
    final body = json.encode(data);

    debugPrint('--- DETALhes DA REQUISIÇÃO (syncProfile) ---');
    debugPrint('URL: $uri');
    debugPrint('HEADERS: $headers');
    debugPrint('BODY: $body');
    debugPrint('------------------------------------------');
    
    final response = await http.post(
      uri,
      headers: headers,
      body: body,
    ).timeout(const Duration(seconds: 15));

    if (response.statusCode == 200 || response.statusCode == 201) {
      debugPrint(
        '[ApiService] SUCESSO (${response.statusCode}) ao sincronizar o perfil.',
      );

      print('[ApiService] RAW BODY: ${response.body}');

      final dynamic jsonData = json.decode(response.body);
      if (jsonData is Map<String, dynamic>) {
        jsonData.forEach((k, v) {
          if (v == null) print('[ApiService] null em "$k"');
        });
      }

      return Usuario.fromJson(jsonData);
    } else {
      debugPrint(
        '[ApiService] ERRO ao sincronizar o perfil. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      
      if (response.statusCode == 500) {
        throw Exception('Erro interno do servidor (500). O backend pode estar temporariamente indisponível.');
      } else if (response.statusCode == 404) {
        throw Exception('Endpoint não encontrado (404). Verifique se o backend está rodando a versão correta.');
      } else if (response.statusCode == 403) {
        throw Exception('Acesso negado (403). O usuário pode não ter permissão para este negócio.');
      } else {
        throw Exception('Falha ao sincronizar o perfil do usuário. Status: ${response.statusCode}');
      }
    }
  }

  Future<Usuario?> updateUserProfile(Map<String, dynamic> data, {Uint8List? imageBytes}) async {
    final uri = Uri.parse('$_baseUrl/me/profile');
    
    final headers = await _getHeaders();
    
    final updateData = <String, dynamic>{
      'nome': data['nome'],
      'telefone': data['telefone'],
    };
    
    if (data.containsKey('endereco') && data['endereco'] != null) {
      updateData['endereco'] = data['endereco'];
    }

    if (imageBytes != null) {
      final base64Image = base64Encode(imageBytes);
      updateData['profile_image'] = 'data:image/jpeg;base64,$base64Image';
    }
    
    updateData.removeWhere((key, value) => value == null || value == '');

    debugPrint('--- [DEBUG] ATUALIZANDO PERFIL ---');
    debugPrint('URL: $uri');
    final safeLogData = Map.from(updateData);
    if (safeLogData.containsKey('profile_image')) {
      safeLogData['profile_image'] = '...base64_data...';
    }
    debugPrint('BODY: ${json.encode(safeLogData)}');
    debugPrint('------------------------------------');
    
    final response = await http.put(
      uri,
      headers: headers,
      body: json.encode(updateData),
    );

    debugPrint('--- [DEBUG] RESPOSTA DA ATUALIZAÇÃO ---');
    debugPrint('Status Code: ${response.statusCode}');
    debugPrint('Response Body: ${response.body}');
    debugPrint('------------------------------------');

    if (response.statusCode == 200) {
      debugPrint('[ApiService] SUCESSO ao atualizar perfil do usuário.');
      
      clearCache('getAllUsersInBusiness');
      clearCache('syncProfile');
      
      try {
        final responseData = json.decode(response.body);
        if (responseData['user'] != null) {
          debugPrint('[ApiService] Retornando dados atualizados do usuário para atualizar AuthService');
          return Usuario.fromJson(responseData['user']);
        }
      } catch (e) {
        debugPrint('[ApiService] Erro ao processar resposta: $e');
      }
      
      return null;
    } else if (response.statusCode == 204) {
      debugPrint('[ApiService] SUCESSO ao atualizar perfil do usuário (204 No Content).');
      
      clearCache('getAllUsersInBusiness');
      clearCache('syncProfile');
      
      return null;
    } else {
      throw Exception('Erro ao atualizar perfil: ${response.statusCode} - ${response.body}');
    }
  }

  Future<void> updateFcmToken(String fcmToken) async {
    final uri = Uri.parse('$_baseUrl/me/fcm-token');
    
    final headers = await _getHeaders();
    
    final updateData = {'fcm_token': fcmToken};

    debugPrint('[ApiService] Enviando token FCM para backend...');
    debugPrint('[ApiService] URL: $uri');
    debugPrint('[ApiService] Token: ${fcmToken.substring(0, 20)}...');
    
    final response = await http.post(
      uri,
      headers: headers,
      body: json.encode(updateData),
    );

    debugPrint('[ApiService] Status Code: ${response.statusCode}');

    if (response.statusCode == 200 || response.statusCode == 201) {
      debugPrint('[ApiService] ✅ Token FCM enviado com sucesso');
    } else {
      debugPrint('[ApiService] ❌ Erro ao enviar token FCM: ${response.body}');
      throw Exception('Erro ao enviar token FCM: ${response.statusCode} - ${response.body}');
    }
  }

  Future<List<Usuario>> getAllUsersInBusiness({String status = 'ativo', bool forceRefresh = false}) async {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final negocioId = await _authService.getNegocioId() ?? 'default';
    
    if (!forceRefresh) {
      final cached = await _cacheManager.get<List<dynamic>>(
        'getAllUsersInBusiness',
        userId,
        negocioId,
        params: {'status': status},
      );
      if (cached != null) {
        return cached.map((json) => Usuario.fromJson(json)).toList();
      }
    }
    
    if (negocioId == 'default') throw Exception('Negocio ID não encontrado.');

    String url = '$_baseUrl/negocios/$negocioId/usuarios';
    if (status == 'all') {
      url += '?status=all';
    }

    final uri = Uri.parse(url);
    
    debugPrint('========== getAllUsersInBusiness DEBUG ==========');
    debugPrint('[ApiService] URL completa: $uri');
    debugPrint('[ApiService] NegocioId extraído: $negocioId');

    try {
      final headers = await _getHeaders();
      debugPrint('[ApiService] TODOS os headers que serão enviados:');
      headers.forEach((key, value) {
        debugPrint('  $key: ${key == 'Authorization' ? '${value.substring(0, 20)}...' : value}');
      });
      
      final response = await http.get(uri, headers: headers);
      
      debugPrint('[ApiService] Status da resposta: ${response.statusCode}');
      debugPrint('[ApiService] Body da resposta: ${response.body}');
      debugPrint('============================================');
      
      if (response.statusCode == 200) {
        debugPrint('[ApiService] SUCESSO (200) ao buscar todos os usuários.');
        final List<dynamic> jsonData = json.decode(response.body);
        final usuarios = jsonData.map((json) => Usuario.fromJson(json)).toList();
        
        await _cacheManager.set(
          'getAllUsersInBusiness',
          jsonData,
          userId,
          negocioId,
          params: {'status': status},
          ttl: const Duration(minutes: 5),
        );
        return usuarios;
      } 
      else if (response.statusCode == 403) {
        debugPrint('[ApiService] AVISO (403): Acesso negado. O usuário não tem permissão para listar todos os usuários. Retornando lista vazia.');
        final emptyList = <Usuario>[];
        await _cacheManager.set(
          'getAllUsersInBusiness',
          [],
          userId,
          negocioId,
          params: {'status': status},
          ttl: const Duration(minutes: 5),
        );
        return emptyList;
      }
      else {
        debugPrint(
          '[ApiService] ERRO ao buscar todos os usuários. Status: ${response.statusCode}, Corpo: ${response.body}',
        );
        throw Exception('Falha ao carregar a lista de usuários.');
      }
    } catch (e) {
      debugPrint(
        '[ApiService] EXCEÇÃO na chamada de getAllUsersInBusiness: $e',
      );
      
      final cached = await _cacheManager.get<List<dynamic>>(
        'getAllUsersInBusiness',
        userId,
        negocioId,
        params: {'status': status},
      );
      if (cached != null) {
        debugPrint('[ApiService] Usando cache como fallback');
        return cached.map((json) => Usuario.fromJson(json)).toList();
      }
      
      rethrow;
    }
  }

  Future<void> updateUserRole(String userId, String newRole) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse(
      '$_baseUrl/negocios/$negocioId/usuarios/$userId/role',
    );
    debugPrint('[ApiService] CHAMANDO PATCH: $uri');

    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
      body: json.encode({'role': newRole}),
    );

    if (response.statusCode != 200) {
      debugPrint(
        '[ApiService] ERRO ao atualizar o papel. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao atualizar o papel do usuário.');
    }

    debugPrint('[ApiService] SUCESSO ao atualizar o papel do usuário.');
    
    clearCache('getAllUsersInBusiness');
  }

  Future<void> updateUserStatus(String userId, String status) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse('$_baseUrl/negocios/$negocioId/usuarios/$userId/status');
    debugPrint('[ApiService] CHAMANDO PATCH (Status): $uri');

    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
      body: json.encode({'status': status}),
    );

    if (response.statusCode != 200) {
      debugPrint(
        '[ApiService] ERRO ao atualizar status. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao atualizar o status do usuário.');
    }
    
    debugPrint('[ApiService] SUCESSO ao atualizar o status do usuário.');
    
    clearCache('getAllUsersInBusiness');
  }

  Future<void> updateUserConsent(
    String userId, 
    bool consentimentoLgpd, 
    DateTime dataConsentimento, 
    String tipoConsentimento
  ) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse('$_baseUrl/negocios/$negocioId/usuarios/$userId/consent');
    debugPrint('[ApiService] CHAMANDO PATCH (Consent): $uri');

    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
      body: json.encode({
        'consentimento_lgpd': consentimentoLgpd,
        'data_consentimento_lgpd': dataConsentimento.toIso8601String(),
        'tipo_consentimento': tipoConsentimento,
      }),
    );

    if (response.statusCode != 200) {
      debugPrint(
        '[ApiService] ERRO ao atualizar consentimento. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao atualizar o consentimento do usuário.');
    }
    
    debugPrint('[ApiService] SUCESSO ao atualizar o consentimento do usuário.');
    
    clearCache('getAllUsersInBusiness');
  }

  Future<void> updateMyConsent(
    bool consentimentoLgpd, 
    DateTime dataConsentimento, 
    String tipoConsentimento
  ) async {
    debugPrint('[ApiService] =============== INICIANDO updateMyConsent ===============');
    debugPrint('[ApiService] Parâmetros: consentimento=$consentimentoLgpd, data=$dataConsentimento, tipo=$tipoConsentimento');
    
    final uri = Uri.parse('$_baseUrl/me/consent');
    debugPrint('[ApiService] URL: $uri');
    
    final headers = await _getHeaders();
    debugPrint('[ApiService] Headers: $headers');
    
    final body = json.encode({
      'consentimento_lgpd': consentimentoLgpd,
      'data_consentimento_lgpd': dataConsentimento.toIso8601String(),
      'tipo_consentimento': tipoConsentimento,
    });
    debugPrint('[ApiService] Body: $body');

    final response = await http.patch(
      uri,
      headers: headers,
      body: body,
    );

    debugPrint('[ApiService] Response Status: ${response.statusCode}');
    debugPrint('[ApiService] Response Body: ${response.body}');

    if (response.statusCode != 200) {
      debugPrint('[ApiService] ERRO ao atualizar meu consentimento. Status: ${response.statusCode}, Corpo: ${response.body}');
      throw Exception('Falha ao atualizar o consentimento.');
    }
    
    debugPrint('[ApiService] =============== SUCESSO updateMyConsent ===============');
  }

  Future<Usuario?> getPatientById(String patienteId) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse('$_baseUrl/negocios/$negocioId/usuarios/$patienteId');
    debugPrint('[ApiService] [TENTATIVA 1] Buscando dados do paciente: $uri');

    try {
      final response = await http.get(uri, headers: await _getHeaders());
      debugPrint('[ApiService] Status: ${response.statusCode}, Corpo: ${response.body}');
      
      if (response.statusCode == 200) {
        debugPrint('[ApiService] SUCESSO ao buscar dados do paciente.');
        final Map<String, dynamic> jsonData = json.decode(response.body);
        return Usuario.fromJson(jsonData);
      } else if (response.statusCode == 403) {
        debugPrint('[ApiService] AVISO (403): Acesso negado ao buscar dados do paciente.');
      } else if (response.statusCode == 404) {
        debugPrint('[ApiService] AVISO (404): Paciente não encontrado no endpoint de usuários.');
      } else {
        debugPrint('[ApiService] ERRO: Status ${response.statusCode}, Corpo: ${response.body}');
      }
    } catch (e) {
      debugPrint('[ApiService] EXCEÇÃO na tentativa 1: $e');
    }

    debugPrint('[ApiService] [TENTATIVA 2] Tentando endpoint direto do paciente...');
    final pacienteUri = Uri.parse('$_baseUrl/pacientes/$patienteId/dados-completos');
    debugPrint('[ApiService] URL: $pacienteUri');
    
    try {
      final response = await http.get(pacienteUri, headers: await _getHeaders());
      debugPrint('[ApiService] Status: ${response.statusCode}, Corpo: ${response.body}');
      
      if (response.statusCode == 200) {
        debugPrint('[ApiService] SUCESSO! Dados completos do paciente encontrados');
        final Map<String, dynamic> jsonData = json.decode(response.body);
        return Usuario.fromJson(jsonData);
      }
    } catch (e) {
      debugPrint('[ApiService] EXCEÇÃO na tentativa 2: $e');
    }
    
    debugPrint('[ApiService] [TENTATIVA 3] Buscando na lista básica de pacientes...');
    try {
      final List<Paciente> pacientes = await getPacientes();
      debugPrint('[ApiService] Encontrados ${pacientes.length} pacientes na lista do técnico');
      
      final paciente = pacientes.where((p) => p.id == patienteId).firstOrNull;
      if (paciente != null) {
        debugPrint('[ApiService] SUCESSO! Paciente encontrado com dados completos do backend');
        
        final usuario = Usuario(
          id: paciente.id,
          nome: paciente.nome,
          email: paciente.email,
          firebaseUid: '',
          roles: {},
          telefone: paciente.telefone,
          endereco: paciente.endereco,
        );
        
        debugPrint('[ApiService] Dados finais: Nome=${usuario.nome}, Email=${usuario.email}, Telefone=${usuario.telefone}, Endereço=${usuario.endereco != null ? "Sim" : "Não"}');
        return usuario;
      } else {
        debugPrint('[ApiService] Paciente não encontrado na lista de pacientes do técnico');
      }
    } catch (e) {
      debugPrint('[ApiService] EXCEÇÃO na tentativa 3: $e');
    }

    debugPrint('[ApiService] FALHA: Não foi possível encontrar dados do paciente por nenhum método');
    return null;
  }

// --- VINCULAÇÕES ---
  
  Future<void> linkPatientToNurse(
    String patientId,
    String? nurseProfileId,
  ) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse('$_baseUrl/negocios/$negocioId/vincular-paciente');
    debugPrint('[ApiService] CHAMANDO POST: $uri');

    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode({
        'paciente_id': patientId,
        'enfermeiro_id': nurseProfileId, // CORREÇÃO APLICADA AQUI
      }),
    );

    if (response.statusCode != 200) {
      debugPrint(
        '[ApiService] ERRO ao vincular/desvincular paciente. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao vincular/desvincular paciente ao enfermeiro.');
    }

    debugPrint('[ApiService] SUCESSO ao vincular/desvincular paciente ao enfermeiro.');
    
    clearCache('getAllUsersInBusiness');
    clearCache('getPacientes');
  }

  Future<void> linkTechniciansToPatient(
    String patientId,
    List<String> technicianIds,
  ) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse(
      '$_baseUrl/negocios/$negocioId/pacientes/$patientId/vincular-tecnicos',
    );
    debugPrint('[ApiService] CHAMANDO PATCH: $uri');

    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
      body: json.encode({'tecnicos_ids': technicianIds}), // CORREÇÃO APLICADA AQUI
    );

    if (response.statusCode != 200) {
      debugPrint(
        '[ApiService] ERRO ao vincular técnicos. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao vincular técnicos ao paciente.');
    }

    debugPrint('[ApiService] SUCESSO ao vincular técnicos ao paciente.');
    
    clearCache('getAllUsersInBusiness');
    clearCache('getPacientes');
  }

  Future<void> linkSupervisorToTechnician(
    String technicianId,
    String? supervisorId,
  ) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse(
      '$_baseUrl/negocios/$negocioId/usuarios/$technicianId/vincular-supervisor',
    );
    debugPrint('[ApiService] CHAMANDO PATCH: $uri');

    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
      body: json.encode({'supervisor_id': supervisorId}),
    );

    if (response.statusCode != 200) {
      debugPrint(
        '[ApiService] ERRO ao vincular/desvincular supervisor. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao vincular/desvincular supervisor ao técnico.');
    }

    debugPrint('[ApiService] SUCESSO ao vincular/desvincular supervisor ao técnico.');
    
    clearCache('getAllUsersInBusiness');
    clearCache('getPacientes');
  }

  Future<void> linkPatientToDoctor(
    String patientId,
    String? doctorId,
  ) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse(
      '$_baseUrl/negocios/$negocioId/pacientes/$patientId/vincular-medico',
    );
    debugPrint('[ApiService] CHAMANDO POST: $uri');

    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode({'medico_id': doctorId}), // Chave confirmada pelo backend
    );

    if (response.statusCode != 200) {
      debugPrint(
        '[ApiService] ERRO ao vincular/desvincular médico. Status: ${response.statusCode}, Corpo: ${response.body}',
      );
      throw Exception('Falha ao vincular/desvincular médico ao paciente.');
    }

    debugPrint('[ApiService] SUCESSO ao vincular/desvincular médico ao paciente.');
    
    clearCache('getAllUsersInBusiness');
    clearCache('getPacientes');
  }

  // --- NOVOS MÉTODOS: CONFIRMAÇÃO DE LEITURA ---

  Future<void> confirmPlanReading(String patientId, String consultaId, String usuarioId) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$patientId/confirmar-leitura');
    
    final body = {
      'plano_version_id': consultaId,
      'usuario_id': usuarioId,
    };

    debugPrint("--- DEBUG: CONFIRMANDO LEITURA DO PLANO ---");
    debugPrint("URL: $uri");
    debugPrint("BODY: ${json.encode(body)}");

    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(body),
    );

    if (response.statusCode != 200) {
      debugPrint("ERRO ao confirmar leitura. Status: ${response.statusCode}");
      debugPrint("Resposta do Servidor: ${response.body}");
      throw Exception('Falha ao confirmar leitura do plano.');
    }

    debugPrint("SUCESSO ao confirmar leitura do plano.");
  }

  Future<Map<String, dynamic>> getPlanReadingStatus(String patientId) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$patientId/confirmar-leitura/status');
    http.Response response; 

    print("--- [DEBUG] INICIANDO getPlanReadingStatus ---");
    print("URL da Requisição: $uri");
    
    try {
      final headers = await _getHeaders();
      print("Cabeçalhos (Headers) Enviados: ${headers.keys.toString()}");

      response = await http.get(uri, headers: headers);

      print("Status Code da Resposta: ${response.statusCode}");
      print("Corpo (Body) da Resposta: ${response.body}");
      print("--- [DEBUG] FINALIZANDO getPlanReadingStatus ---");

      if (response.statusCode == 200) {
        return json.decode(response.body);
      } else {
        throw Exception('Código: ${response.statusCode}, Resposta: ${response.body}');
      }
    } catch (e) {
      print("--- [DEBUG] EXCEÇÃO EM getPlanReadingStatus ---");
      print(e.toString());
      print("--- [DEBUG] FIM DA EXCEÇÃO ---");
      rethrow;
    }
  }

  @deprecated
  Future<bool> checkPlanReading(String patientId, String date) async {
    try {
      final status = await getPlanReadingStatus(patientId);
      return status['leitura_confirmada'] ?? false;
    } catch (e) {
      return false;
    }
  }

  // --- CHECKLIST DIÁRIO COM SUPORTE A FILTROS ---

  Future<List<ChecklistItem>> getDailyChecklist(
    String patientId, {
    String? date,
    bool forceRefresh = false,
  }) async {
    try {
      final queryDate = date ?? DateFormat('yyyy-MM-dd').format(DateTime.now());
      final userId = _authService.currentUser?.id ?? 'anonymous';
      final negocioId = await _authService.getNegocioId() ?? 'default';
      
      if (!forceRefresh) {
        final cached = await _cacheManager.get<List<dynamic>>(
          'getDailyChecklist_$queryDate',
          userId,
          negocioId,
          params: {'pacienteId': patientId},
        );
        if (cached != null) {
          return cached.map((json) => ChecklistItem.fromJson(json)).toList();
        }
      }
      
      String url = '$_baseUrl/pacientes/$patientId/checklist-diario?data=$queryDate';
      final uri = Uri.parse(url);

      debugPrint('--- DEBUG: CHAMANDO API DO CHECKLIST DIÁRIO ---');
      debugPrint('URL: $uri');

      final response = await http.get(uri, headers: await _getHeaders());

      debugPrint('Status Code: ${response.statusCode}');
      debugPrint('Corpo da Resposta: ${response.body}');
      debugPrint('--------------------------------------------------');

      if (response.statusCode == 200) {
        final List<dynamic> jsonData = json.decode(response.body);
        final items = jsonData.map((json) => ChecklistItem.fromJson(json)).toList();
        
        await _cacheManager.set(
          'getDailyChecklist_$queryDate',
          jsonData,
          userId,
          negocioId,
          params: {'pacienteId': patientId},
          ttl: const Duration(minutes: 2),
        );
        
        return items;
      } else if (response.statusCode == 404) {
        debugPrint('[CHECKLIST] Checklist não encontrado para paciente $patientId em $queryDate');
        return [];
      } else if (response.statusCode == 401) {
        throw Exception('Sem autorização para acessar checklist diário. Verifique seu login.');
      } else if (response.statusCode == 403) {
        throw Exception('Sem permissão para acessar checklist diário deste paciente.');
      } else {
        debugPrint('[CHECKLIST ERROR] Status: ${response.statusCode}, Body: ${response.body}');
        throw Exception('Falha ao buscar checklist diário (Status: ${response.statusCode}).');
      }
    } catch (e) {
      debugPrint('[CHECKLIST ERROR] Erro na requisição: $e');
      if (e is Exception && e.toString().contains('Status:')) {
        rethrow; 
      }
      return [];
    }
  }

  Future<void> updateChecklistItem(
    String patientId,
    String itemId,
    bool isCompleted, {
    String? date,
  }) async {
    final queryDate = date ?? DateFormat('yyyy-MM-dd').format(DateTime.now());
    String url = '$_baseUrl/pacientes/$patientId/checklist-diario/$itemId?data=$queryDate';
    
    final uri = Uri.parse(url);

    try {
      final response = await http.patch(
        uri,
        headers: await _getHeaders(),
        body: json.encode({'concluido': isCompleted}),
      ).timeout(const Duration(seconds: 30));

      if (response.statusCode != 200) {
        throw Exception(ErrorHandler.getApiErrorMessage(response));
      }
      
      await invalidateRelatedCache('checklist_updated', pacienteId: patientId);
      
    } catch (e) {
      debugPrint('Erro em updateChecklistItem: $e');
      throw Exception('Falha ao atualizar o item do checklist. Verifique sua conexão ou tente novamente mais tarde.');
    }
  }

  Future<List<Usuario>> getTecnicosSupervisionados(String pacienteId) async {
    final negocioId = await _authService.getNegocioId() ?? 'default';
    final userRole = _authService.currentUser?.roles?[negocioId] ?? 'unknown';
    final userId = _authService.currentUser?.id ?? 'anonymous';
    
    final uri = Uri.parse(
      '$_baseUrl/pacientes/$pacienteId/tecnicos-supervisionados',
    );

    debugPrint('--- DEBUG: CHAMANDO TÉCNICOS SUPERVISIONADOS ---');
    debugPrint('URL: $uri');
    debugPrint('User Role: $userRole');
    debugPrint('User ID: $userId');

    final response = await http.get(uri, headers: await _getHeaders());

    debugPrint('Status Code: ${response.statusCode}');
    debugPrint('Corpo da Resposta: ${response.body}');
    debugPrint('--------------------------------------------------');

    if (response.statusCode == 200) {
      final List<dynamic> jsonData = json.decode(response.body);
      
      debugPrint('--- DEBUG: NOMES DOS TÉCNICOS RECEBIDOS ---');
      for (int i = 0; i < jsonData.length && i < 5; i++) {
        final tecnicoData = jsonData[i];
        debugPrint('Técnico $i: nome="${tecnicoData['nome']}", email="${tecnicoData['email']}"');
      }
      debugPrint('--------------------------------------------');
      
      return jsonData.map((json) => Usuario.fromJson(json)).toList();
    } else {
      throw Exception(
        'Falha ao buscar técnicos supervisionados. Status code: ${response.statusCode}',
      );
    }
  }

  // --- REGISTROS DIÁRIOS COM FILTROS ATUALIZADOS ---

  Future<List<RegistroDiario>> getRegistrosDiario(
    String pacienteId, {
    String? date,
    String? tipo,
    bool forceRefresh = false,
  }) async {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final negocioId = await _authService.getNegocioId() ?? 'default';
    final queryDate = date ?? DateFormat('yyyy-MM-dd').format(DateTime.now());
    
    if (!forceRefresh) {
      final cached = await _cacheManager.get<List<dynamic>>(
        'getRegistrosDiario_$queryDate',
        userId,
        negocioId,
        params: {'pacienteId': pacienteId, 'tipo': tipo ?? 'all'},
      );
      if (cached != null) {
        return cached.map((json) => RegistroDiario.fromJson(json)).toList();
      }
    }
    
    String url = '$_baseUrl/pacientes/$pacienteId/registros';
    
    final queryParams = <String>[];
    if (date != null) queryParams.add('data=$date');
    if (tipo != null) queryParams.add('tipo=$tipo');
    
    if (queryParams.isNotEmpty) {
      url += '?${queryParams.join('&')}';
    }

    final uri = Uri.parse(url);
    final response = await http.get(uri, headers: await _getHeaders());

    debugPrint('--- RESPOSTA DO SERVIDOR (getRegistrosDiario) ---');
    debugPrint('URL: $uri');
    debugPrint('Status Code: ${response.statusCode}');
    debugPrint('Body: ${response.body}');
    debugPrint('------------------------------------------------');

    if (response.statusCode == 200) {
      final List<dynamic> jsonData = json.decode(response.body);
      final registros = jsonData.map((json) => RegistroDiario.fromJson(json)).toList();
      
      await _cacheManager.set(
        'getRegistrosDiario_$queryDate',
        jsonData,
        userId,
        negocioId,
        params: {'pacienteId': pacienteId, 'tipo': tipo ?? 'all'},
        ttl: const Duration(minutes: 2),
      );
      
      return registros;
    } else {
      throw Exception(
        'Failed to load registros diario. Status code: ${response.statusCode}',
      );
    }
  }

  Future<RegistroDiario> createRegistroDiario(
    String pacienteId,
    Map<String, dynamic> data,
  ) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/registros');
    
    final negocioId = await _authService.getNegocioId();
    final completeData = {
      ...data,
      'paciente_id': pacienteId,
      'negocio_id': negocioId,
    };
    
    debugPrint('--- CRIANDO REGISTRO DIÁRIO ---');
    debugPrint('URL: $uri');
    debugPrint('Data: ${json.encode(completeData)}');
    
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(completeData),
    );

    debugPrint('Status Code: ${response.statusCode}');
    debugPrint('Response Body: ${response.body}');
    debugPrint('--------------------------------');

    if (response.statusCode == 201) {
      final registro = RegistroDiario.fromJson(json.decode(response.body));
      
      await invalidateRelatedCache('registry_created', pacienteId: pacienteId);
      
      return registro;
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<RegistroDiario> updateRegistroDiario(
    String pacienteId,
    String registroId,
    Map<String, dynamic> data,
  ) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/registros/$registroId');
    
    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );

    if (response.statusCode == 200) {
      return RegistroDiario.fromJson(json.decode(response.body));
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> deleteRegistroDiario(
    String pacienteId,
    String registroId
  ) async {
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/registros/$registroId');
    
    final response = await http.delete(uri, headers: await _getHeaders());

    if (response.statusCode != 204 && response.statusCode != 200) {
      throw Exception(
        'Failed to delete registro diario. Status code: ${response.statusCode}',
      );
    }
  }

  Future<List<RegistroDiario>> getRegistrosDiarioByDate(
    String pacienteId,
    String date,
  ) async {
    return getRegistrosDiario(pacienteId, date: date);
  }

  Future<List<RegistroDiario>> getRegistrosDiarioByType(
    String pacienteId,
    String tipo,
  ) async {
    return getRegistrosDiario(pacienteId, tipo: tipo);
  }
  
  Future<void> addStructuredDiaryEntry(
    String patientId,
    Map<String, dynamic> entryData,
  ) async {
    await createRegistroDiario(patientId, entryData);
  }

  // --- CACHE PREDICTIVO ---

  void _preloadPatientDetails(List<Paciente> pacientes) {
    if (pacientes.isEmpty) return;
    
    Future.delayed(const Duration(milliseconds: 500), () async {
      for (final paciente in pacientes) {
        try {
          final userId = _authService.currentUser?.id ?? 'anonymous';
          final negocioId = await _authService.getNegocioId() ?? 'default';
          
          final cached = await _cacheManager.get<Map<String, dynamic>>(
            'getFichaCompleta',
            userId,
            negocioId,
            params: {
              'pacienteId': paciente.id,
              'consultaId': 'null',
            },
          );
          
          if (cached == null) {
            debugPrint('[Cache Predictivo] Pre-carregando ficha de ${paciente.nome}');
            await getFichaCompleta(paciente.id, forceRefresh: false);
            
            await Future.delayed(const Duration(milliseconds: 200));
          } else {
            debugPrint('[Cache Predictivo] Ficha de ${paciente.nome} já em cache');
          }
        } catch (e) {
          debugPrint('[Cache Predictivo] Erro ao pre-carregar ${paciente.nome}: $e');
        }
      }
    });
  }

  Future<void> preloadRelatedData(String context, {String? pacienteId, String? userRole}) async {
    try {
      final userId = _authService.currentUser?.id ?? 'anonymous';
      final negocioId = await _authService.getNegocioId() ?? 'default';
      
      switch (context) {
        case 'patient_details':
          if (pacienteId != null) {
            debugPrint('[Cache Predictivo] Pre-carregando dados relacionados do paciente');
            
            final today = DateFormat('yyyy-MM-dd').format(DateTime.now());
            final checklistCached = await _cacheManager.get<List<dynamic>>(
              'getDailyChecklist_$today',
              userId,
              negocioId,
              params: {'pacienteId': pacienteId},
            );
            
            if (checklistCached == null) {
              Future.delayed(const Duration(milliseconds: 300), () async {
                try {
                  await getDailyChecklist(pacienteId, date: today);
                } catch (e) {
                  debugPrint('[Cache Predictivo] Erro ao pre-carregar checklist: $e');
                }
              });
            }
            
            final registrosCached = await _cacheManager.get<List<dynamic>>(
              'getRegistrosDiario_$today',
              userId,
              negocioId,
              params: {'pacienteId': pacienteId},
            );
            
            if (registrosCached == null) {
              Future.delayed(const Duration(milliseconds: 600), () async {
                try {
                  await getRegistrosDiario(pacienteId, date: today);
                } catch (e) {
                  debugPrint('[Cache Predictivo] Erro ao pre-carregar registros: $e');
                }
              });
            }
          }
          break;
          
        case 'home_screen':
          if (userRole == 'admin') {
            final usersCached = await _cacheManager.get<List<dynamic>>(
              'getAllUsersInBusiness',
              userId,
              negocioId,
              params: {'status': 'ativo'},
            );
            
            if (usersCached == null) {
              Future.delayed(const Duration(milliseconds: 800), () async {
                try {
                  await getAllUsersInBusiness(status: 'ativo', forceRefresh: false);
                } catch (e) {
                  debugPrint('[Cache Predictivo] Erro ao pre-carregar usuários: $e');
                }
              });
            }
          }
          break;
          
        case 'supervisor_diary':
          if (pacienteId != null) {
            Future.delayed(const Duration(milliseconds: 400), () async {
              try {
                await getTecnicosSupervisionados(pacienteId);
              } catch (e) {
                debugPrint('[Cache Predictivo] Erro ao pre-carregar técnicos: $e');
              }
            });
          }
          break;
      }
    } catch (e) {
      debugPrint('[Cache Predictivo] Erro geral: $e');
    }
  }

  Future<void> invalidateRelatedCache(String action, {String? pacienteId}) async {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final negocioId = await _authService.getNegocioId() ?? 'default';
    
    try {
      switch (action) {
        case 'patient_updated':
          if (pacienteId != null) {
            await _cacheManager.clear(
              pattern: 'getFichaCompleta',
              userId: userId,
              negocioId: negocioId,
            );
            
            await _cacheManager.clear(
              pattern: 'getPacientes',
              userId: userId,
              negocioId: negocioId,
            );
            
            debugPrint('[Cache] Invalidado cache do paciente $pacienteId');
          }
          break;
          
        case 'checklist_updated':
          if (pacienteId != null) {
            final today = DateFormat('yyyy-MM-dd').format(DateTime.now());
            await _cacheManager.clear(
              pattern: 'getDailyChecklist_$today',
              userId: userId,
              negocioId: negocioId,
            );
            
            await _cacheManager.clear(
              pattern: 'getFichaCompleta',
              userId: userId,
              negocioId: negocioId,
            );
            
            await _cacheManager.clear(
              pattern: 'getFichaCompleta_pacienteId=$pacienteId',
              userId: userId,
              negocioId: negocioId,
            );
            
            _cache.clear();
            debugPrint('[Cache] FORÇADO limpeza do cache em memória também');
            
            debugPrint('[Cache] Invalidado cache do checklist E ficha completa do paciente $pacienteId');
          }
          break;
          
        case 'registry_created':
          if (pacienteId != null) {
            final today = DateFormat('yyyy-MM-dd').format(DateTime.now());
            await _cacheManager.clear(
              pattern: 'getRegistrosDiario_$today',
              userId: userId,
              negocioId: negocioId,
            );
            
            debugPrint('[Cache] Invalidado cache de registros do paciente $pacienteId');
          }
          break;
          
        case 'user_role_updated':
          await _cacheManager.clear(
            pattern: 'getAllUsersInBusiness',
            userId: userId,
            negocioId: negocioId,
          );
          
          debugPrint('[Cache] Invalidado cache de usuários');
          break;
      }
    } catch (e) {
      debugPrint('[Cache] Erro ao invalidar cache relacionado: $e');
    }
  }

  // --- SUPORTE PSICOLÓGICO ---

  Future<List<SuportePsicologico>> getSuportePsicologico(String pacienteId, {bool forceRefresh = false}) async {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final negocioId = await _authService.getNegocioId() ?? 'default';
    
    if (!forceRefresh) {
      final cached = await _cacheManager.get<List<dynamic>>(
        'getSuportePsicologico',
        userId,
        negocioId,
        params: {'pacienteId': pacienteId},
      );
      if (cached != null) {
        return cached.map((json) => SuportePsicologico.fromJson(json)).toList();
      }
    }
    
    final negocioIdQuery = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/suporte-psicologico?negocio_id=$negocioIdQuery');
    
    debugPrint('--- [SUPORTE PSICO] CHAMANDO GET ---');
    debugPrint('URL: $uri');
    
    final response = await http.get(uri, headers: await _getHeaders());
    
    debugPrint('Status: ${response.statusCode}');
    debugPrint('Body: ${response.body}');
    debugPrint('---------------------------------------');
    
    if (response.statusCode == 200) {
      final List<dynamic> jsonData = json.decode(response.body);
      final suportes = jsonData.map((json) => SuportePsicologico.fromJson(json)).toList();
      
      await _cacheManager.set(
        'getSuportePsicologico',
        jsonData,
        userId,
        negocioId,
        params: {'pacienteId': pacienteId},
        ttl: const Duration(minutes: 5),
      );
      
      return suportes;
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<SuportePsicologico> createSuportePsicologico(
    String pacienteId,
    Map<String, dynamic> data,
  ) async {
    final negocioId = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/suporte-psicologico?negocio_id=$negocioId');
    
    debugPrint('--- [SUPORTE PSICO] CRIANDO ---');
    debugPrint('URL: $uri');
    debugPrint('Data: ${json.encode(data)}');
    
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );
    
    debugPrint('Status: ${response.statusCode}');
    debugPrint('Response: ${response.body}');
    debugPrint('----------------------------------');
    
    if (response.statusCode == 201) {
      final suporte = SuportePsicologico.fromJson(json.decode(response.body));
      
      await invalidateSuportePsicologicoCache(pacienteId);
      
      return suporte;
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<SuportePsicologico> updateSuportePsicologico(
    String pacienteId,
    String suporteId,
    Map<String, dynamic> data,
  ) async {
    final negocioId = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/suporte-psicologico/$suporteId?negocio_id=$negocioId');
    
    debugPrint('--- [SUPORTE PSICO] ATUALIZANDO ---');
    debugPrint('URL: $uri');
    debugPrint('Data: ${json.encode(data)}');
    
    final response = await http.put(
      uri,
      headers: await _getHeaders(),
      body: json.encode(data),
    );
    
    debugPrint('Status: ${response.statusCode}');
    debugPrint('Response: ${response.body}');
    debugPrint('-------------------------------------');
    
    if (response.statusCode == 200) {
      final suporte = SuportePsicologico.fromJson(json.decode(response.body));
      
      await invalidateSuportePsicologicoCache(pacienteId);
      
      return suporte;
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> deleteSuportePsicologico(String pacienteId, String suporteId) async {
    final negocioId = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/suporte-psicologico/$suporteId?negocio_id=$negocioId');
    
    debugPrint('--- [SUPORTE PSICO] DELETANDO ---');
    debugPrint('URL: $uri');
    
    final response = await http.delete(uri, headers: await _getHeaders());
    
    debugPrint('Status: ${response.statusCode}');
    debugPrint('-----------------------------------');
    
    if (response.statusCode == 200 || response.statusCode == 204) {
      await invalidateSuportePsicologicoCache(pacienteId);
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> invalidateSuportePsicologicoCache(String pacienteId) async {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final negocioId = await _authService.getNegocioId() ?? 'default';
    
    try {
      await _cacheManager.clear(
        pattern: 'getSuportePsicologico',
        userId: userId,
        negocioId: negocioId,
      );
      debugPrint('[Cache] Invalidado cache do suporte psicológico do paciente $pacienteId');
    } catch (e) {
      debugPrint('[Cache] Erro ao invalidar cache do suporte psicológico: $e');
    }
  }

  // ================== RELATÓRIOS MÉDICOS ==================

  Future<RelatorioMedico> createRelatorio(String pacienteId, String medicoId, {String? conteudo}) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/relatorios?negocio_id=$negocioId');
    debugPrint('[ApiService] Criando relatório médico: $uri');
    
    final bodyMap = {
      'medico_id': medicoId,
      'negocio_id': negocioId,
    };
    
    if (conteudo != null && conteudo.trim().isNotEmpty) {
      bodyMap['conteudo'] = conteudo.trim();
    }
    
    final body = json.encode(bodyMap);
    
    debugPrint('[ApiService] Body: $body');

    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: body,
    );

    debugPrint('[ApiService] Response Status: ${response.statusCode}');
    debugPrint('[ApiService] Response Body: ${response.body}');

    if (response.statusCode == 201) {
      final Map<String, dynamic> jsonData = json.decode(response.body);
      return RelatorioMedico.fromJson(jsonData);
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<List<RelatorioMedico>> getRelatoriosPaciente(String pacienteId) async {
    try {
      final negocioId = await _authService.getNegocioId();
      final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/relatorios?negocio_id=$negocioId');
      debugPrint('[ApiService] ===== INICIO getRelatoriosPaciente =====');
      debugPrint('[ApiService] Buscando relatórios do paciente: $uri');
      debugPrint('[ApiService] Paciente ID: $pacienteId');
      
      final headers = await _getHeaders();
      debugPrint('[ApiService] Headers gerados com sucesso');
      debugPrint('[ApiService] negocio-id presente: ${headers.containsKey('negocio-id')}');
      debugPrint('[ApiService] negocio-id valor: ${headers['negocio-id']}');
      debugPrint('[ApiService] Content-Type: ${headers['Content-Type']}');
      debugPrint('[ApiService] Authorization presente: ${headers.containsKey('Authorization')}');
      debugPrint('[ApiService] Total de headers: ${headers.length}');

      debugPrint('[ApiService] Fazendo requisição HTTP...');
      final response = await http.get(uri, headers: headers)
          .timeout(const Duration(seconds: 30));
      
      debugPrint('[ApiService] Requisição completada');
      debugPrint('[ApiService] Response Status: ${response.statusCode}');
      debugPrint('[ApiService] Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final List<dynamic> jsonList = json.decode(response.body);
        debugPrint('[ApiService] Relatórios encontrados: ${jsonList.length}');
        for (int i = 0; i < jsonList.length; i++) {
          final fotosCount = (jsonList[i]['fotos'] as List<dynamic>?)?.length ?? 0;
          debugPrint('[ApiService] Relatório $i: ID=${jsonList[i]['id']}, Status=${jsonList[i]['status']}, Fotos=$fotosCount');
        }
        return jsonList.map((json) => RelatorioMedico.fromJson(json)).toList();
      } else {
        debugPrint('[ApiService] ERRO ao buscar relatórios - Status: ${response.statusCode}');
        debugPrint('[ApiService] ERRO - Response body: ${response.body}');
        if (response.statusCode == 500) {
          debugPrint('[ApiService] ERRO 500 - Erro interno do servidor. Possíveis causas:');
          debugPrint('[ApiService] - Headers malformados ou ausentes');
          debugPrint('[ApiService] - Problema na validação do negocio-id');
          debugPrint('[ApiService] - Erro interno do backend');
          throw Exception('Erro interno do servidor ao buscar relatórios. Tente novamente em alguns instantes.');
        }
        throw Exception(ErrorHandler.getApiErrorMessage(response));
      }
    } catch (e, stackTrace) {
      debugPrint('[ApiService] ===== ERRO CAPTURADO =====');
      debugPrint('[ApiService] Erro: $e');
      debugPrint('[ApiService] Tipo do erro: ${e.runtimeType}');
      debugPrint('[ApiService] Stack trace: $stackTrace');
      debugPrint('[ApiService] ============================');
      rethrow;
    }
  }

  Future<void> addRelatorioFotos(String relatorioId, List<String> fotoPaths) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse('$_baseUrl/relatorios/$relatorioId/fotos');
    debugPrint('[ApiService] Adicionando fotos ao relatório: $uri');
    
    final request = http.MultipartRequest('POST', uri);
    final headers = await _getHeaders();
    
    request.headers.addAll(headers);
    
    for (int i = 0; i < fotoPaths.length; i++) {
      final fotoPath = fotoPaths[i];
      try {
        final file = await http.MultipartFile.fromPath('files', fotoPath);
        request.files.add(file);
        debugPrint('[ApiService] Foto adicionada: $fotoPath');
      } catch (e) {
        debugPrint('[ApiService] Erro ao adicionar foto $fotoPath: $e');
      }
    }

    final response = await request.send();
    final responseBody = await response.stream.bytesToString();
    
    debugPrint('[ApiService] Response Status: ${response.statusCode}');
    debugPrint('[ApiService] Response Body: $responseBody');

    if (response.statusCode != 200 && response.statusCode != 201) {
      throw Exception('Erro ao adicionar fotos: ${response.statusCode}');
    }
  }

  Future<List<RelatorioMedico>> getRelatoriosPendentes() async {
    final uri = Uri.parse('$_baseUrl/medico/relatorios/pendentes');
    final headers = await _getHeaders();
    debugPrint('[ApiService] ===== INICIO getRelatoriosPendentes =====');
    debugPrint('[ApiService] Buscando relatórios pendentes: $uri');
    debugPrint('[ApiService] Headers sendo enviados: negocio-id=${headers['negocio-id']}, Authorization=${headers['Authorization'] != null ? 'presente' : 'ausente'}');

    final response = await http.get(uri, headers: headers);
    debugPrint('[ApiService] Response Status: ${response.statusCode}');
    debugPrint('[ApiService] Response Body: ${response.body}');

    if (response.statusCode == 200) {
      final List<dynamic> jsonList = json.decode(response.body);
      debugPrint('[ApiService] Relatórios pendentes encontrados: ${jsonList.length}');
      for (int i = 0; i < jsonList.length; i++) {
        debugPrint('[ApiService] Relatório $i: ID=${jsonList[i]['id']}, medicoId=${jsonList[i]['medico_id']}, Status=${jsonList[i]['status']}');
      }
      return jsonList.map((json) => RelatorioMedico.fromJson(json)).toList();
    } else {
      debugPrint('[ApiService] ERRO ao buscar relatórios pendentes: ${response.statusCode}');
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<List<RelatorioMedico>> getRelatoriosMedico({String? status}) async {
    String endpoint = '$_baseUrl/medico/relatorios';
    if (status != null && status.isNotEmpty) {
      endpoint += '?status=$status';
    }
    
    final uri = Uri.parse(endpoint);
    final headers = await _getHeaders();
    debugPrint('[ApiService] ===== INICIO getRelatoriosMedico =====');
    debugPrint('[ApiService] Buscando relatórios do médico: $uri');

    final response = await http.get(uri, headers: headers);
    debugPrint('[ApiService] Response Status: ${response.statusCode}');

    if (response.statusCode == 200) {
      final List<dynamic> jsonList = json.decode(response.body);
      debugPrint('[ApiService] Relatórios encontrados: ${jsonList.length}');
      
      for (int i = 0; i < jsonList.length; i++) {
        final relatorio = jsonList[i];
        debugPrint('[ApiService] Relatório $i:');
        debugPrint('[ApiService] - ID: ${relatorio['id']}');
        debugPrint('[ApiService] - Status: ${relatorio['status']}');
        debugPrint('[ApiService] - Medico ID: ${relatorio['medico_id']}');
        debugPrint('[ApiService] - Paciente: ${relatorio['paciente']?['nome'] ?? 'null'}');
        debugPrint('[ApiService] - Data criação: ${relatorio['data_criacao']}');
        debugPrint('[ApiService] - Data avaliação: ${relatorio['data_avaliacao']}');
      }
      
      return jsonList.map((json) => RelatorioMedico.fromJson(json)).toList();
    } else {
      debugPrint('[ApiService] ERRO ao buscar relatórios do médico: ${response.statusCode}');
      debugPrint('[ApiService] Response Body: ${response.body}');
      throw Exception('Erro ao buscar relatórios: ${response.statusCode}');
    }
  }

  Future<RelatorioDetalhado> getRelatorioDetalhado(String relatorioId) async {
    final uri = Uri.parse('$_baseUrl/relatorios/$relatorioId');
    debugPrint('[ApiService] Buscando detalhes do relatório: $uri');

    final response = await http.get(uri, headers: await _getHeaders());
    debugPrint('[ApiService] Response Status: ${response.statusCode}');
    debugPrint('[ApiService] Response Body: ${response.body}');

    if (response.statusCode == 200) {
      final Map<String, dynamic> jsonData = json.decode(response.body);
      return RelatorioDetalhado.fromJson(jsonData);
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> aprovarRelatorio(String relatorioId) async {
    final uri = Uri.parse('$_baseUrl/relatorios/$relatorioId/aprovar');
    debugPrint('[ApiService] Aprovando relatório: $uri');

    final response = await http.post(uri, headers: await _getHeaders());
    debugPrint('[ApiService] Response Status: ${response.statusCode}');

    if (response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> recusarRelatorio(String relatorioId, String motivo) async {
    final uri = Uri.parse('$_baseUrl/relatorios/$relatorioId/recusar');
    debugPrint('[ApiService] Recusando relatório: $uri');
    
    final body = json.encode({'motivo': motivo});
    debugPrint('[ApiService] Body: $body');

    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: body,
    );

    debugPrint('[ApiService] Response Status: ${response.statusCode}');

    if (response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<List<Usuario>> getMedicos() async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) throw Exception('Negocio ID não encontrado.');

    final uri = Uri.parse('$_baseUrl/negocios/$negocioId/usuarios?role=medico');
    debugPrint('[ApiService] Buscando médicos: $uri');

    final response = await http.get(uri, headers: await _getHeaders());
    debugPrint('[ApiService] Response Status: ${response.statusCode}');
    debugPrint('[ApiService] Response Body: ${response.body}');

    if (response.statusCode == 200) {
      final List<dynamic> jsonList = json.decode(response.body);
      final usuarios = jsonList.map((json) => Usuario.fromJson(json)).toList();
      
      final medicos = usuarios.where((usuario) {
        final userRoles = usuario.roles;
        if (userRoles != null && userRoles.containsKey(negocioId)) {
          final role = userRoles[negocioId];
          return role == 'medico';
        }
        return false;
      }).toList();
      
      debugPrint('[ApiService] Filtrados ${medicos.length} médicos de ${usuarios.length} usuários');
      for (var medico in medicos) {
        final role = medico.roles?[negocioId] ?? 'N/A';
        debugPrint('[ApiService] Médico válido: ${medico.id} - ${medico.nome} - Role: $role');
      }
      
      return medicos;
    } else if (response.statusCode == 404 || response.statusCode == 422) {
      debugPrint('[ApiService] Nenhum médico encontrado, retornando lista vazia');
      return <Usuario>[];
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  // --- NOTIFICAÇÕES ---

  Future<List<Notificacao>> getNotificacoes({bool forceRefresh = false}) async {
    final userId = _authService.currentUser?.id ?? 'anonymous';
    final negocioId = await _authService.getNegocioId() ?? 'default';
    
    if (!forceRefresh) {
      final cached = await _cacheManager.get<List<dynamic>>(
        'getNotificacoes',
        userId,
        negocioId,
      );
      if (cached != null) {
        return cached.map((json) => Notificacao.fromJson(json)).toList();
      }
    }

    final uri = Uri.parse('$_baseUrl/notificacoes');
    final response = await http.get(uri, headers: await _getHeaders());

    if (response.statusCode == 200) {
      final List<dynamic> jsonList = json.decode(response.body);
      final notificacoes = jsonList.map((json) => Notificacao.fromJson(json)).toList();
      
      await _cacheManager.set(
        'getNotificacoes',
        jsonList,
        userId,
        negocioId,
      );
      
      return notificacoes;
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<int> getNotificacoesNaoLidasContagem() async {
    final uri = Uri.parse('$_baseUrl/notificacoes/nao-lidas/contagem');
    final response = await http.get(uri, headers: await _getHeaders());

    if (response.statusCode == 200) {
      final responseData = json.decode(response.body);
      return responseData['count'] as int? ?? 0;
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<void> marcarNotificacaoComoLida(String notificacaoId) async {
    final uri = Uri.parse('$_baseUrl/notificacoes/marcar-como-lida');
    final response = await http.post(
      uri,
      headers: await _getHeaders(),
      body: json.encode({'notificacao_id': notificacaoId}),
    );

    if (response.statusCode != 204 && response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }

    // Limpar cache
    clearCache('getNotificacoes');
  }

  Future<void> marcarTodasNotificacoesComoLidas() async {
    final uri = Uri.parse('$_baseUrl/notificacoes/ler-todas');
    final response = await http.post(uri, headers: await _getHeaders());

    if (response.statusCode != 204 && response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }

    // Limpar cache
    clearCache('getNotificacoes');
  }

  Future<Map<String, dynamic>> agendarNotificacao({
    required String pacienteId,
    required String titulo,
    required String mensagem,
    required DateTime dataAgendamento,
  }) async {
    final negocioId = await _authService.getNegocioId();
    if (negocioId == null) {
      throw Exception('Negócio ID não encontrado');
    }

    final uri = Uri.parse('$_baseUrl/notificacoes/agendar');
    final response = await http.post(
      uri,
      headers: {
        ...await _getHeaders(),
        'negocio-id': negocioId,
      },
      body: json.encode({
        'paciente_id': pacienteId,
        'titulo': titulo,
        'mensagem': mensagem,
        'data_agendamento': dataAgendamento.toIso8601String(),
      }),
    );

    if (response.statusCode == 200 || response.statusCode == 201) {
      return json.decode(response.body);
    } else {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }

  Future<TarefaAgendada> createTarefa(String pacienteId, Map<String, dynamic> data) async {
    debugPrint('========== createTarefa DEBUG ==========');
    debugPrint('PacienteId: $pacienteId');
    debugPrint('Data: ${json.encode(data)}');
    
    final negocioId = await _authService.getNegocioId();
    final uri = Uri.parse('$_baseUrl/pacientes/$pacienteId/tarefas?negocio_id=$negocioId');
    debugPrint('NegocioId: $negocioId');
    debugPrint('URL: $uri');
    
    try {
      final headers = await _getHeaders();
      debugPrint('Headers obtidos com sucesso');
      
      final response = await http.post(
        uri,
        headers: headers,
        body: json.encode(data),
      );

      debugPrint('Status Code: ${response.statusCode}');
      debugPrint('Response Body: ${response.body}');
      debugPrint('=======================================');

      if (response.statusCode == 200 || response.statusCode == 201) {
        return TarefaAgendada.fromJson(json.decode(response.body));
      } else {
        final errorMessage = ErrorHandler.getApiErrorMessage(response);
        debugPrint('Erro da API: $errorMessage');
        throw Exception(errorMessage);
      }
    } catch (e) {
      debugPrint('ERRO em createTarefa: $e');
      rethrow;
    }
  }

  Future<List<TarefaAgendada>> getTarefas(String pacienteId, {String? status}) async {
    final negocioId = await _authService.getNegocioId();
    String url = '$_baseUrl/pacientes/$pacienteId/tarefas?negocio_id=$negocioId';
    if (status != null && status.isNotEmpty) {
      url += '&status=$status';
    }

    debugPrint('========== getTarefas DEBUG ==========');
    debugPrint('PacienteId: $pacienteId');
    debugPrint('NegocioId: $negocioId');
    debugPrint('Status: $status');
    debugPrint('URL: $url');

    final uri = Uri.parse(url);
    
    try {
      final headers = await _getHeaders();
      debugPrint('Headers obtidos com sucesso');
      
      final response = await http.get(uri, headers: headers);
      
      debugPrint('Status Code: ${response.statusCode}');
      debugPrint('Response Body: ${response.body}');
      debugPrint('=====================================');

      if (response.statusCode == 200) {
        final List<dynamic> jsonList = json.decode(response.body);
        debugPrint('Tarefas encontradas: ${jsonList.length}');
        return jsonList.map((json) => TarefaAgendada.fromJson(json)).toList();
      } else {
        final errorMessage = ErrorHandler.getApiErrorMessage(response);
        debugPrint('Erro da API: $errorMessage');
        throw Exception(errorMessage);
      }
    } catch (e) {
      debugPrint('ERRO em getTarefas: $e');
      rethrow;
    }
  }

  Future<void> concluirTarefa(String tarefaId) async {
    final uri = Uri.parse('$_baseUrl/tarefas/$tarefaId/concluir');
    final response = await http.patch(
      uri,
      headers: await _getHeaders(),
    );

    if (response.statusCode != 200) {
      throw Exception(ErrorHandler.getApiErrorMessage(response));
    }
  }
}